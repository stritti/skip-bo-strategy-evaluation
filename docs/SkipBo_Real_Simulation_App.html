<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skip-Bo: Echte Runden Simulation & Analyse</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Vue.js 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Phosphor Icons (Lightweight Icons) -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght{400;500;700}&display=swap"
        rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #334155;
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: 300px;
        }

        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }

        /* Log Styling */
        .log-container {
            height: 150px;
            overflow-y: hidden;
            position: relative;
            background: #0f172a;
            color: #4ade80;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            border-radius: 0.5rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.3);
        }

        /* Table Styling */
        .data-table th {
            background-color: #f1f5f9;
            color: #475569;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .data-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.875rem;
        }

        .data-table tr:hover {
            background-color: #f8fafc;
        }

        .data-table tr:last-child td {
            border-bottom: none;
        }

        /* Custom Transitions */
        .fade-enter-active,
        .fade-leave-active {
            transition: opacity 0.3s ease;
        }

        .fade-enter-from,
        .fade-leave-to {
            opacity: 0;
        }

        .list-enter-active,
        .list-leave-active {
            transition: all 0.3s ease;
        }

        .list-enter-from,
        .list-leave-to {
            opacity: 0;
            transform: translateX(-10px);
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            cursor: pointer;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #ef4444;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
            margin-top: -6px;
        }

        input[type=range]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #ef4444;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body class="antialiased">

    <div id="app" class="flex flex-col min-h-screen">
        <!-- Navigation -->
        <nav class="bg-white border-b border-gray-200 sticky top-0 z-50 shadow-sm backdrop-blur-md bg-opacity-90">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between h-16">
                    <div class="flex items-center gap-2">
                        <div class="bg-red-600 text-white p-1.5 rounded-lg shadow-sm">
                            <i class="ph-bold ph-cards text-xl"></i>
                        </div>
                        <div>
                            <h1 class="text-lg font-bold tracking-tight text-gray-900 leading-tight">Skip-Bo Analyst
                            </h1>
                            <div class="text-[10px] uppercase font-bold text-gray-400 tracking-wider">Echte Simulation
                            </div>
                        </div>
                    </div>
                    <div class="hidden md:flex items-center space-x-1 text-sm font-medium text-gray-500">
                        <button @click="currentView = 'dashboard'" :class="navClass('dashboard')"
                            class="px-3 py-2 rounded-md transition-colors">Dashboard</button>
                        <button @click="currentView = 'data'" :class="navClass('data')"
                            class="px-3 py-2 rounded-md transition-colors flex items-center gap-1">
                            <i class="ph ph-table"></i> Datensätze
                        </button>
                        <button @click="currentView = 'rules'" :class="navClass('rules')"
                            class="px-3 py-2 rounded-md transition-colors flex items-center gap-1">
                            <i class="ph ph-scroll"></i> Regeln
                        </button>
                        <button @click="currentView = 'strategy'" :class="navClass('strategy')"
                            class="px-3 py-2 rounded-md transition-colors">Strategie</button>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Main Content Area -->
        <main class="flex-grow">

            <!-- VIEW: DASHBOARD (Simulation & Charts) -->
            <div v-if="currentView === 'dashboard'" class="max-w-7xl mx-auto px-4 py-8 space-y-12">

                <!-- Simulation Control Panel -->
                <div class="bg-white rounded-2xl shadow-sm border border-gray-200 overflow-hidden">
                    <div class="border-b border-gray-100 bg-gray-50/50 px-6 py-4 flex justify-between items-center">
                        <div>
                            <h2 class="text-lg font-bold text-gray-900">Simulation Control Center</h2>
                            <p class="text-sm text-gray-500">Modellierung von {{ maxGames }} echten Spielrunden</p>
                        </div>
                        <div class="text-right">
                            <div class="text-xs font-bold text-gray-400 uppercase tracking-wider">Fortschritt</div>
                            <div class="text-2xl font-mono font-bold text-gray-900 tabular-nums">{{ formattedCounter }}
                                <span class="text-sm text-gray-400 font-normal">/ {{
                                    maxGamesConfig.toLocaleString('de-DE') }}</span></div>
                        </div>
                    </div>

                    <div class="p-6 grid grid-cols-1 lg:grid-cols-3 gap-8">

                        <!-- Settings -->
                        <div class="lg:col-span-1 border-r pr-6 border-gray-100 hidden lg:block">
                            <h3 class="font-bold text-gray-800 mb-4 flex items-center gap-2">
                                <i class="ph-bold ph-gear-six text-xl text-red-600"></i>Simulationseinstellungen
                            </h3>
                            <div class="bg-red-50 p-4 rounded-lg border border-red-200">
                                <label for="gameCountSlider" class="block text-sm font-medium text-red-800 mb-2">
                                    Anzahl der Spielrunden:
                                    <span class="font-bold text-lg">{{ maxGamesConfig.toLocaleString('de-DE') }}</span>
                                </label>
                                <input id="gameCountSlider" type="range" v-model.number="maxGamesConfig" :min="minGames"
                                    :max="maxGamesLimit" :step="stepGames" :disabled="isSimulating">
                                <div class="flex justify-between text-xs text-red-700 mt-2 font-mono font-bold">
                                    <span>{{ minGames }}</span>
                                    <span>{{ maxGamesLimit.toLocaleString('de-DE') }}</span>
                                </div>
                                <p class="text-xs text-red-700/80 mt-2">
                                    Je höher die Zahl, desto genauer die Statistik (aber länger die Laufzeit).
                                </p>
                            </div>
                        </div>

                        <!-- Live Log & Progress -->
                        <div class="lg:col-span-2">
                            <div class="log-container mb-4 flex flex-col-reverse p-4 font-mono relative">
                                <div
                                    class="absolute top-0 left-0 right-0 h-8 bg-gradient-to-b from-[#0f172a] to-transparent pointer-events-none z-10">
                                </div>
                                <div
                                    class="absolute bottom-0 left-0 right-0 h-8 bg-gradient-to-t from-[#0f172a] to-transparent pointer-events-none z-10">
                                </div>

                                <transition-group name="list">
                                    <div v-for="log in logs" :key="log.id"
                                        class="py-0.5 whitespace-nowrap overflow-hidden text-ellipsis">
                                        <span class="text-gray-500">{{ log.time }}</span>
                                        <span :class="log.color">{{ log.type }}</span>
                                        <span class="text-gray-300">> {{ log.text }}</span>
                                    </div>
                                </transition-group>
                                <div v-if="logs.length === 0"
                                    class="flex h-full items-center justify-center text-gray-600 italic">
                                    System bereit. Warte auf Startbefehl...
                                </div>
                            </div>

                            <!-- Progress Bar -->
                            <div class="relative w-full bg-gray-100 rounded-full h-2 mb-1 overflow-hidden">
                                <div class="absolute top-0 left-0 h-full bg-red-600 transition-all duration-100"
                                    :style="{ width: progress + '%' }"></div>
                            </div>
                            <div class="flex justify-between text-xs text-gray-400 font-medium mb-4">
                                <span>0%</span>
                                <span>{{ Math.round(progress) }}%</span>
                                <span>100%</span>
                            </div>

                            <!-- Action Button: Handles Start and Reset -->
                            <button @click="isFinished ? resetSimulation() : runSimulation()" :disabled="isSimulating"
                                class="w-full h-16 rounded-xl font-bold text-lg shadow-lg transition-all duration-200 flex justify-center items-center gap-3 transform hover:-translate-y-1 active:translate-y-0 disabled:transform-none disabled:opacity-70 disabled:cursor-not-allowed"
                                :class="buttonClass">
                                <i v-if="isSimulating" class="ph-bold ph-spinner animate-spin text-2xl"></i>
                                <i v-else-if="isFinished" class="ph-bold ph-arrow-counter-clockwise text-2xl"></i>
                                <i v-else class="ph-bold ph-play text-2xl"></i>
                                {{ buttonText }}
                            </button>
                            <p class="text-xs text-center text-gray-400 mt-3 px-4">
                                Klicken Sie, um die {{ maxGamesConfig.toLocaleString('de-DE') }} Spiele zu starten oder
                                den Zustand zurückzusetzen.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Results Section (Revealed after Sim) -->
                <transition name="fade">
                    <div v-show="isFinished">
                        <!-- KPI Cards -->
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                            <div
                                class="bg-white p-5 rounded-xl border border-gray-100 shadow-sm hover:shadow-md transition-shadow">
                                <div class="flex items-center gap-2 mb-2">
                                    <div class="bg-blue-50 text-blue-600 p-1.5 rounded-md"><i
                                            class="ph-bold ph-clock"></i></div>
                                    <span class="text-xs font-bold text-gray-400 uppercase">Ø Züge (Real)</span>
                                </div>
                                <div class="text-3xl font-bold text-gray-900">{{ averageTurns.toFixed(1) }}</div>
                            </div>
                            <div
                                class="bg-white p-5 rounded-xl border border-gray-100 shadow-sm hover:shadow-md transition-shadow">
                                <div class="flex items-center gap-2 mb-2">
                                    <div class="bg-red-50 text-red-600 p-1.5 rounded-md"><i
                                            class="ph-bold ph-trend-up"></i></div>
                                    <span class="text-xs font-bold text-gray-400 uppercase">Win-Rate KI</span>
                                </div>
                                <div class="text-3xl font-bold text-red-600">{{ (winRateP1 * 100).toFixed(1) }}%</div>
                            </div>
                            <div
                                class="bg-white p-5 rounded-xl border border-gray-100 shadow-sm hover:shadow-md transition-shadow">
                                <div class="flex items-center gap-2 mb-2">
                                    <div class="bg-green-50 text-green-600 p-1.5 rounded-md"><i
                                            class="ph-bold ph-user-focus"></i></div>
                                    <span class="text-xs font-bold text-gray-400 uppercase">P1 Vorteil</span>
                                </div>
                                <div class="text-3xl font-bold text-green-600">{{ ((winRateP1 - 0.5) * 200).toFixed(1)
                                    }}%</div>
                            </div>
                            <div
                                class="bg-white p-5 rounded-xl border border-gray-100 shadow-sm hover:shadow-md transition-shadow">
                                <div class="flex items-center gap-2 mb-2">
                                    <div class="bg-purple-50 text-purple-600 p-1.5 rounded-md"><i
                                            class="ph-bold ph-magic-wand"></i></div>
                                    <span class="text-xs font-bold text-gray-400 uppercase">Ø Joker/Spiel</span>
                                </div>
                                <div class="text-3xl font-bold text-gray-900">{{ averageJokers.toFixed(1) }}</div>
                            </div>
                        </div>

                        <!-- Charts Grid -->
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                            <div class="bg-white p-6 rounded-xl border border-gray-100 shadow-sm">
                                <h3 class="font-bold text-gray-900 mb-1">Siegesverteilung</h3>
                                <p class="text-sm text-gray-500 mb-6">Optimierte Strategie vs. Zufall</p>
                                <div class="chart-container">
                                    <canvas ref="winRateChartRef"></canvas>
                                </div>
                            </div>
                            <div class="bg-white p-6 rounded-xl border border-gray-100 shadow-sm">
                                <h3 class="font-bold text-gray-900 mb-1">Spielzüge Histogramm</h3>
                                <p class="text-sm text-gray-500 mb-6">Häufigkeitsverteilung der Spieldauer</p>
                                <div class="chart-container">
                                    <canvas ref="durationChartRef"></canvas>
                                </div>
                            </div>
                        </div>

                        <div
                            class="bg-red-50 border border-red-200 rounded-lg p-4 flex flex-col sm:flex-row items-center justify-between gap-3">
                            <div class="flex items-center gap-3">
                                <i class="ph-fill ph-database text-red-600 text-xl"></i>
                                <span class="text-sm text-red-800 font-medium">Die Rohdaten der {{
                                    maxGamesConfig.toLocaleString('de-DE') }} Spiele wurden generiert und die Statistik
                                    hochgerechnet.</span>
                            </div>
                            <button @click="currentView = 'data'"
                                class="text-sm bg-white text-red-600 px-4 py-2 rounded-lg border border-red-200 font-bold hover:bg-red-50 shadow-sm transition w-full sm:w-auto">
                                Zur Datentabelle →
                            </button>
                        </div>
                    </div>
                </transition>
            </div>

            <!-- VIEW: DATA EXPLORER (Table & Export) -->
            <div v-if="currentView === 'data'" class="max-w-7xl mx-auto px-4 py-8">
                <div class="mb-6 flex flex-col md:flex-row md:items-center justify-between gap-4">
                    <div>
                        <h2 class="text-2xl font-bold text-gray-900">Ergebnis-Tabelle</h2>
                        <p class="text-gray-500 text-sm">Auszug aus der simulierten Datenbank ({{
                            totalRows.toLocaleString('de-DE') }} Einträge)</p>
                    </div>

                    <div class="flex items-center gap-2">
                        <span v-if="!isFinished"
                            class="text-xs text-orange-500 bg-orange-50 px-2 py-1 rounded font-bold">
                            ⚠ Simulation läuft noch
                        </span>
                        <button @click="downloadCSV" :disabled="!isFinished"
                            class="flex items-center gap-2 bg-red-600 text-white px-4 py-2 rounded-lg font-medium text-sm hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed shadow-md transition-all">
                            <i class="ph-bold ph-download-simple"></i>
                            CSV Exportieren
                        </button>
                    </div>
                </div>

                <div
                    class="bg-white rounded-xl border border-gray-200 shadow-sm overflow-hidden flex flex-col min-h-[600px]">
                    <!-- Table Header Filter Mockup -->
                    <div class="bg-gray-50 border-b border-gray-200 px-4 py-3 flex gap-4 overflow-x-auto">
                        <div
                            class="flex items-center gap-2 bg-white border border-gray-300 rounded px-2 py-1 text-xs text-gray-600">
                            <i class="ph-bold ph-funnel"></i> Filter: Alle
                        </div>
                        <div
                            class="flex items-center gap-2 bg-white border border-gray-300 rounded px-2 py-1 text-xs text-gray-600">
                            <i class="ph-bold ph-arrows-down-up"></i> Sortierung: ID (DESC)
                        </div>
                    </div>

                    <div class="overflow-x-auto flex-grow">
                        <table class="w-full data-table">
                            <thead>
                                <tr>
                                    <th class="w-24">Game ID</th>
                                    <th>Sieger</th>
                                    <th>Züge</th>
                                    <th>Dauer (Sim)</th>
                                    <th>Startspieler</th>
                                    <th>Joker benutzt</th>
                                    <th>Strategie Typ</th>
                                </tr>
                            </thead>
                            <tbody v-if="isFinished">
                                <tr v-for="row in paginatedData" :key="row.id" class="transition-colors">
                                    <td class="font-mono text-xs text-gray-500">#{{ row.id }}</td>
                                    <td>
                                        <span
                                            :class="row.winner === 'Spieler 1 (KI)' ? 'text-green-600 bg-green-50' : 'text-blue-600 bg-blue-50'"
                                            class="px-2 py-1 rounded text-xs font-bold">
                                            {{ row.winner }}
                                        </span>
                                    </td>
                                    <td class="font-medium text-gray-900">{{ row.turns }}</td>
                                    <td class="text-gray-500 text-xs">{{ row.duration }}ms</td>
                                    <td class="text-xs">{{ row.starter }}</td>
                                    <td>
                                        <div class="flex gap-0.5">
                                            <div v-for="n in row.jokers" :key="n"
                                                class="w-1.5 h-1.5 rounded-full bg-purple-400"></div>
                                            <span v-if="row.jokers === 0" class="text-gray-300">-</span>
                                        </div>
                                    </td>
                                    <td><span
                                            class="text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded-full border border-gray-200">{{
                                            row.strategy }}</span></td>
                                </tr>
                            </tbody>
                            <tbody v-else>
                                <tr>
                                    <td colspan="7" class="h-64 text-center text-gray-400 bg-gray-50">
                                        <div class="flex flex-col items-center justify-center gap-2">
                                            <i class="ph-duotone ph-table text-4xl mb-2 opacity-50"></i>
                                            <p>Keine Daten vorhanden.</p>
                                            <p class="text-xs">Bitte starte zuerst die Simulation im Dashboard.</p>
                                        </div>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Pagination -->
                    <div class="border-t border-gray-200 p-4 bg-gray-50 flex justify-between items-center"
                        v-if="isFinished">
                        <div class="text-xs text-gray-500">
                            Zeige <span class="font-bold text-gray-900">{{ (currentPage - 1) * pageSize + 1 }}</span>
                            bis <span class="font-bold text-gray-900">{{ Math.min(currentPage * pageSize, totalRows)
                                }}</span> von {{ totalRows.toLocaleString('de-DE') }} Ergebnissen
                        </div>
                        <div class="flex items-center gap-2">
                            <button @click="prevPage" :disabled="currentPage === 1"
                                class="p-2 rounded hover:bg-white border border-transparent hover:border-gray-300 disabled:opacity-30 transition">
                                <i class="ph-bold ph-caret-left"></i>
                            </button>
                            <span class="text-sm font-bold text-gray-700 w-8 text-center">{{ currentPage }}</span>
                            <button @click="nextPage" :disabled="currentPage * pageSize >= totalRows"
                                class="p-2 rounded hover:bg-white border border-transparent hover:border-gray-300 disabled:opacity-30 transition">
                                <i class="ph-bold ph-caret-right"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- VIEW: RULES (New View) -->
            <div v-if="currentView === 'rules'" class="max-w-4xl mx-auto px-4 py-8">
                <div class="text-center mb-10">
                    <h2 class="text-2xl font-bold text-gray-900">Offizielle Skip-Bo Spielregeln</h2>
                    <p class="text-gray-500">Diese Regeln bilden die Grundlage für die statistische Analyse.</p>
                </div>

                <div class="bg-white rounded-xl shadow-lg border border-gray-200 p-8 space-y-8">
                    <!-- Rules content remains the same as it correctly reflects the game rules -->
                    <section>
                        <h3 class="text-xl font-bold text-red-600 mb-3 flex items-center gap-2">
                            <i class="ph-bold ph-target text-2xl"></i> 1. Spielziel
                        </h3>
                        <p class="text-gray-700">Der Spieler, der als Erster alle Karten seines **Spielerstapels
                            (Stockpile)** in aufsteigender Reihenfolge von 1 bis 12 auf die Baukartenstapel ablegt,
                            gewinnt die Runde.</p>
                        <p class="text-sm italic mt-2 text-gray-500">Die Simulation basiert auf einem Spiel zu zweit mit
                            30 Karten im Spielerstapel.</p>
                    </section>

                    <hr class="border-gray-200">

                    <section>
                        <h3 class="text-xl font-bold text-red-600 mb-3 flex items-center gap-2">
                            <i class="ph-bold ph-deck-of-cards text-2xl"></i> 2. Kartentypen & Setup
                        </h3>
                        <div class="space-y-4">
                            <div class="bg-gray-50 p-4 rounded-lg border border-gray-100">
                                <p class="font-semibold text-gray-800 mb-2">Karten-Zusammensetzung (162 Karten)</p>
                                <ul class="list-disc list-inside text-gray-700 space-y-1 ml-4">
                                    <li>**144 Zahlenkarten:** 1er bis 12er (jeweils 12 Stück).</li>
                                    <li>**18 Skip-Bo-Karten:** Joker, die jede beliebige Zahl ersetzen können.</li>
                                </ul>
                            </div>

                            <p class="font-semibold text-gray-800">Spielvorbereitung:</p>
                            <ul class="list-disc list-inside text-gray-700 space-y-1 ml-4">
                                <li>Jeder Spieler erhält seinen verdeckten **Spielerstapel** (30 Karten).</li>
                                <li>Die oberste Karte des Spielerstapels wird aufgedeckt.</li>
                                <li>Der Rest bildet den **Ziehstapel**.</li>
                                <li>Es gibt Platz für bis zu **vier Baukartenstapel** in der Mitte.</li>
                            </ul>
                        </div>
                    </section>

                    <hr class="border-gray-200">

                    <section>
                        <h3 class="text-xl font-bold text-red-600 mb-3 flex items-center gap-2">
                            <i class="ph-bold ph-sign-post text-2xl"></i> 3. Spielablauf
                        </h3>

                        <p class="text-gray-700 mb-4">Ein Zug läuft typischerweise wie folgt ab:</p>
                        <ol class="list-decimal list-inside text-gray-700 space-y-3 ml-4">
                            <li>
                                **Karten ziehen:** Zu Beginn seines Zuges zieht der Spieler so viele Karten, dass er
                                **fünf Handkarten** hat (sofern der Ziehstapel dies zulässt).
                            </li>
                            <li>
                                **Karten spielen:** Der Spieler versucht, so viele Karten wie möglich zu spielen. Er
                                kann Karten nutzen aus:
                                <ul class="list-disc list-inside text-gray-600 space-y-1 mt-1 ml-4">
                                    <li>der Hand (alle 5 Karten sind verfügbar).</li>
                                    <li>dem **obersten Spielerstapel** (oberste Karte).</li>
                                    <li>den **eigenen Ablagestapeln** (nur die oberste Karte).</li>
                                </ul>
                            </li>
                            <li>
                                **Baukartenstapel:** Karten werden in aufsteigender Reihenfolge (1, 2, 3... bis 12) auf
                                die vier Baukartenstapel in der Mitte gespielt. Eine 12 schließt den Stapel ab, dieser
                                wird entfernt und ein neuer Stapel kann begonnen werden.
                            </li>
                            <li>
                                **Zug beenden:** Der Zug endet, indem der Spieler **eine** Karte aus seiner Hand auf
                                **einen seiner maximal vier Ablagestapel** legt.
                            </li>
                            <li>
                                **Sonderfall:** Wird der Spielerstapel eines Spielers komplett abgebaut, zieht dieser
                                **sofort 5 neue Handkarten** und darf weiterspielen (sofern er die Voraussetzungen
                                erfüllt).
                            </li>
                        </ol>
                    </section>

                    <hr class="border-gray-200">

                    <section>
                        <h3 class="text-xl font-bold text-red-600 mb-3 flex items-center gap-2">
                            <i class="ph-bold ph-diamond text-2xl"></i> 4. Skip-Bo-Karten (Joker)
                        </h3>
                        <p class="text-gray-700">Die Skip-Bo-Karte kann jede beliebige Zahl von 1 bis 12 ersetzen. Sie
                            sind strategisch extrem wichtig, da sie Lücken füllen und den Abbau des Spielerstapels
                            erleichtern können.</p>
                        <div class="bg-red-50 p-4 rounded-lg border border-red-200 mt-4">
                            <p class="font-bold text-red-800">Strategisches Kernelement der KI-Analyse:</p>
                            <p class="text-sm text-red-700">Die KI (Spieler 1) nutzt Skip-Bo-Karten **nur**, wenn damit
                                garantiert die oberste Karte des Spielerstapels gespielt werden kann oder ein Stapel
                                beendet wird. Die Zufallsstrategie (Spieler 2) nutzt sie sofort bei der erstbesten
                                Gelegenheit.</p>
                        </div>
                    </section>

                </div>
            </div>

            <!-- VIEW: STRATEGY -->
            <div v-if="currentView === 'strategy'" class="max-w-4xl mx-auto px-4 py-8">
                <div class="text-center mb-10">
                    <h2 class="text-2xl font-bold text-gray-900">Strategie-Labor</h2>
                    <p class="text-gray-500">Interaktive Szenarien basierend auf den Tabellendaten</p>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
                    <button v-for="(scen, id) in scenarios" :key="id" @click="activeScenarioId = id"
                        class="p-4 rounded-xl border text-left transition hover:shadow-md relative overflow-hidden group"
                        :class="activeScenarioId === id ? 'bg-white border-red-500 ring-1 ring-red-500 shadow-md' : 'bg-white border-gray-200 hover:border-red-300'">
                        <div v-if="activeScenarioId === id" class="absolute top-0 right-0 p-1">
                            <div class="w-2 h-2 rounded-full bg-red-500"></div>
                        </div>
                        <div class="font-bold text-sm"
                            :class="activeScenarioId === id ? 'text-red-800' : 'text-gray-800'">{{ scen.title }}</div>
                        <div class="text-xs mt-1 text-gray-500 line-clamp-2">{{ scen.desc }}</div>
                    </button>
                </div>

                <div class="bg-white rounded-2xl shadow-sm border border-gray-200 p-8">
                    <h4 class="text-lg font-bold text-gray-900 mb-2">{{ activeScenario.title }}</h4>
                    <div class="flex justify-center gap-8 my-8">
                        <div v-for="stack in activeScenario.stacks" :key="stack.label" class="text-center">
                            <div class="text-[10px] uppercase font-bold text-gray-400 mb-1 tracking-wider">{{
                                stack.label }}</div>
                            <div class="w-16 h-24 rounded-lg flex items-center justify-center font-bold text-xl shadow-sm border"
                                :class="stack.styleClass">
                                {{ stack.value }}
                            </div>
                        </div>
                    </div>
                    <div class="bg-gray-50 rounded-lg p-4 text-sm text-gray-700 leading-relaxed border-l-4 border-red-500"
                        v-html="activeScenario.analysis"></div>
                </div>
            </div>

        </main>

        <!-- Footer -->
        <footer class="border-t border-gray-200 mt-auto bg-white">
            <div
                class="max-w-7xl mx-auto px-4 py-6 flex flex-col md:flex-row justify-between items-center text-xs text-gray-400">
                <div>&copy; 2025 Skip-Bo Simulation Project</div>
                <div class="mt-2 md:mt-0">Generiert mit Vue.js 3 & Chart.js</div>
            </div>
        </footer>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, reactive, watch, nextTick } = Vue;

        // --- 1. Skip-Bo Game Logic Core (Unchanged) ---
        // Card values: 1-12 for numbers, 0 for Skip-Bo (Joker)
        const JOKER_VALUE = 0;
        const STOCKPILE_SIZE = 30; // 30 cards for a 2-player game
        const BUILD_PILE_COUNT = 4;
        const DISCARD_PILE_COUNT = 4;
        const HAND_SIZE = 5;

        /**
         * Helper to shuffle an array (Fisher-Yates)
         * @param {Array} array 
         */
        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex != 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        /**
         * Represents a single Skip-Bo player.
         */
        class Player {
            constructor(id, isAI) {
                this.id = id; // 0 or 1
                this.name = `Spieler ${id + 1}`;
                this.isAI = isAI;
                this.stockpile = []; // Main goal stack
                this.hand = [];      // 5 cards
                this.discardPiles = Array.from({ length: DISCARD_PILE_COUNT }, () => []); // 4 stacks
                this.jokersPlayed = 0;
            }

            /** Gets the top card of the stockpile, or null if empty. */
            get topStockpileCard() {
                return this.stockpile.length > 0 ? this.stockpile[this.stockpile.length - 1] : null;
            }

            /** Returns all playable cards (hand, stockpile, and top of discard piles). */
            get playableCards() {
                const playable = [...this.hand];
                if (this.topStockpileCard !== null) {
                    playable.push(this.topStockpileCard);
                }
                this.discardPiles.forEach(pile => {
                    if (pile.length > 0) {
                        playable.push(pile[pile.length - 1]);
                    }
                });
                return playable;
            }
        }

        /**
         * Core Skip-Bo Game Simulation Logic.
         */
        class SkipBoGame {
            constructor(app) {
                this.app = app;
                this.players = [new Player(0, true), new Player(1, false)]; // P1: KI, P2: Random
                this.drawPile = [];
                this.discardPile = []; // Used to reconstruct the draw pile
                this.buildPiles = Array.from({ length: BUILD_PILE_COUNT }, () => []);
                this.currentPlayerIndex = 0;
                this.turnCount = 0;
                this.winner = null;
            }

            /**
             * Creates the standard 162-card deck and shuffles it.
             */
            createDeck() {
                let cards = [];
                // 144 Numbered Cards (12 sets of 1-12)
                for (let i = 0; i < 12; i++) {
                    for (let j = 1; j <= 12; j++) {
                        cards.push(j);
                    }
                }
                // 18 Skip-Bo Cards (Jokers)
                for (let i = 0; i < 18; i++) {
                    cards.push(JOKER_VALUE);
                }
                this.drawPile = shuffle(cards);
            }

            /**
             * Deals the cards to players.
             */
            deal() {
                this.players.forEach(player => {
                    player.stockpile = this.drawPile.splice(0, STOCKPILE_SIZE);
                    player.hand = [];
                    player.jokersPlayed = 0;
                    player.discardPiles = Array.from({ length: DISCARD_PILE_COUNT }, () => []);
                });
                this.buildPiles = Array.from({ length: BUILD_PILE_COUNT }, () => []);
                this.currentPlayerIndex = 0; // P1 starts
            }

            /**
             * Reconstitutes the draw pile from the discard pile and shuffles it.
             */
            refillDrawPile() {
                if (this.drawPile.length === 0) {
                    this.drawPile = shuffle(this.discardPile);
                    this.discardPile = [];
                    this.app.logEvent('INFO', 'Ziehstapel wurde aus Ablagestapel neu gebildet.');
                }
            }

            /**
             * Draws cards for the current player up to HAND_SIZE.
             */
            drawCards(player) {
                const needed = HAND_SIZE - player.hand.length;
                for (let i = 0; i < needed; i++) {
                    if (this.drawPile.length === 0) {
                        this.refillDrawPile();
                    }
                    if (this.drawPile.length > 0) {
                        player.hand.push(this.drawPile.pop());
                    } else {
                        break; // No cards left anywhere
                    }
                }
            }

            /**
             * Attempts to play a card to a build pile.
             * @param {number} cardValue - The value of the card (1-12 or 0/Joker).
             * @param {number} pileIndex - Index of the build pile (0-3).
             * @returns {boolean} True if the card was successfully played.
             */
            playCardToBuildPile(cardValue, pileIndex) {
                const currentPileTop = this.buildPiles[pileIndex].length > 0 ? this.buildPiles[pileIndex][this.buildPiles[pileIndex].length - 1] : 0;
                const requiredValue = currentPileTop + 1;

                if (cardValue === JOKER_VALUE || cardValue === requiredValue) {
                    // Determine the actual value used for the pile
                    const finalValue = cardValue === JOKER_VALUE ? requiredValue : cardValue;

                    this.buildPiles[pileIndex].push(finalValue);

                    if (cardValue === JOKER_VALUE) this.app.tempJokersPlayed++;

                    // Check for completion (12 played)
                    if (finalValue === 12) {
                        this.discardPile.push(...this.buildPiles[pileIndex]);
                        this.buildPiles[pileIndex] = [];
                        this.app.logEvent('SUCCESS', `Bau-Stapel ${pileIndex + 1} beendet!`);
                    }
                    return true;
                }
                return false;
            }

            /**
             * Tries to play a specific card type from a specific location.
             * @param {Player} player 
             * @param {string} source - 'hand', 'stockpile', or 'discard-[index]'
             * @param {number} cardValue - The value of the card to play.
             * @returns {boolean} True if a play was made.
             */
            makePlay(player, source, cardValue) {
                for (let i = 0; i < BUILD_PILE_COUNT; i++) {
                    if (this.playCardToBuildPile(cardValue, i)) {
                        // Remove card from source
                        if (source === 'stockpile') {
                            player.stockpile.pop();
                            this.app.logEvent('INFO', `${player.name}: Spielerstapel (${player.stockpile.length}) auf Bau-Stapel ${i + 1} gespielt.`);
                            if (player.stockpile.length === 0) {
                                this.app.logEvent('SUCCESS', `${player.name} hat seinen Spielerstapel geleert!`);
                                this.winner = player;
                            }
                        } else if (source.startsWith('discard-')) {
                            const pileIndex = parseInt(source.split('-')[1]);
                            player.discardPiles[pileIndex].pop();
                            this.app.logEvent('INFO', `${player.name}: Ablage-Stapel ${pileIndex + 1} auf Bau-Stapel ${i + 1} gespielt.`);
                        } else if (source === 'hand') {
                            const index = player.hand.indexOf(cardValue);
                            if (index !== -1) {
                                player.hand.splice(index, 1);
                                this.app.logEvent('INFO', `${player.name}: Handkarte ${cardValue} auf Bau-Stapel ${i + 1} gespielt.`);
                            } else if (cardValue === JOKER_VALUE) {
                                // Find and remove the Joker
                                const jokerIndex = player.hand.indexOf(JOKER_VALUE);
                                if (jokerIndex !== -1) {
                                    player.hand.splice(jokerIndex, 1);
                                    this.app.logEvent('INFO', `${player.name}: Joker von Hand auf Bau-Stapel ${i + 1} gespielt.`);
                                }
                            }
                        }
                        return true;
                    }
                }
                return false;
            }

            /**
             * Implements the core game loop for one player's turn.
             */
            playerTurn(player) {
                let playsMade = true;
                let cardsPlayedThisTurn = 0;

                this.drawCards(player); // 1. Draw cards up to 5

                while (playsMade && this.winner === null) {
                    playsMade = false;

                    // --- Strategy Implementation ---

                    // Determine the next required card values for each build pile
                    const requiredValues = this.buildPiles.map(p => p.length > 0 ? p[p.length - 1] + 1 : 1);

                    // --- 1. Prioritize Stockpile Card Play (KI Strategy: Always play Stockpile if possible) ---
                    const topStockpile = player.topStockpileCard;
                    if (topStockpile !== null) {
                        // The KI (P1) is smart: Check if the stockpile card or a joker can immediately play the stockpile card
                        for (let requiredVal of requiredValues) {
                            if (requiredVal > 12) continue; // Pile is full and will be cleared

                            // Check if Stockpile card itself works (or is a Joker)
                            if (topStockpile === requiredVal || topStockpile === JOKER_VALUE) {
                                if (this.makePlay(player, 'stockpile', topStockpile)) {
                                    playsMade = true;
                                    cardsPlayedThisTurn++;
                                    // If stockpile was emptied, draw 5 new cards immediately and continue turn
                                    if (player.stockpile.length === 0) {
                                        this.app.logEvent('SUCCESS', `${player.name} hat gewonnen!`);
                                        return;
                                    }
                                    break; // Restart play loop after a successful move
                                }
                            }
                        }
                    }

                    if (playsMade) continue; // Restart play loop

                    // --- 2. Play from Hand or Discard Piles (P1 KI Strategy: Play lowest number first, prioritize Hand over Discard) ---

                    let playCandidates = [];

                    // Candidate: Hand cards (excluding Jokers)
                    player.hand.filter(c => c !== JOKER_VALUE).forEach(card => {
                        requiredValues.forEach((requiredVal, pileIndex) => {
                            if (card === requiredVal) {
                                playCandidates.push({ source: 'hand', card: card, priority: card * 10 - requiredVal }); // Low number is better
                            }
                        });
                    });

                    // Candidate: Discard piles (only top card)
                    player.discardPiles.forEach((pile, pileIndex) => {
                        const topCard = pile.length > 0 ? pile[pile.length - 1] : null;
                        if (topCard !== null && topCard !== JOKER_VALUE) {
                            requiredValues.forEach((requiredVal, buildPileIndex) => {
                                if (topCard === requiredVal) {
                                    playCandidates.push({ source: `discard-${pileIndex}`, card: topCard, priority: 1000 + topCard }); // Discards are generally lower priority
                                }
                            });
                        }
                    });

                    // Candidate: Jokers (Hand only)
                    const jokerInHand = player.hand.includes(JOKER_VALUE);
                    if (jokerInHand) {
                        requiredValues.forEach((requiredVal, pileIndex) => {
                            if (requiredVal <= 12) {
                                // KI Strategy: Only use Joker if it advances the stockpile or completes a pile (12)
                                const isStrategic = requiredVal === 12 || requiredVal === player.topStockpileCard;
                                if (player.isAI) {
                                    if (isStrategic) {
                                        playCandidates.push({ source: 'hand', card: JOKER_VALUE, priority: 5000 + requiredVal }); // Highest priority for strategic Joker use
                                    }
                                } else {
                                    // Random player uses Joker when possible
                                    playCandidates.push({ source: 'hand', card: JOKER_VALUE, priority: 100 + requiredVal });
                                }
                            }
                        });
                    }

                    if (topStockpile === JOKER_VALUE && player.isAI) {
                        // If the stockpile card is a Joker, it must be used if any play is possible
                        requiredValues.forEach((requiredVal, pileIndex) => {
                            if (requiredVal <= 12) {
                                playCandidates.push({ source: 'stockpile', card: JOKER_VALUE, priority: 9999 + requiredVal }); // Absolute highest priority
                            }
                        });
                    }

                    if (playCandidates.length > 0) {
                        let bestPlay;
                        if (player.isAI) {
                            // P1 (KI): Find the highest priority play
                            bestPlay = playCandidates.sort((a, b) => b.priority - a.priority)[0];
                        } else {
                            // P2 (Random): Pick a random valid play
                            bestPlay = playCandidates[Math.floor(Math.random() * playCandidates.length)];
                        }

                        if (bestPlay) {
                            // The makePlay function needs the value of the card played, not the final value.
                            if (this.makePlay(player, bestPlay.source, bestPlay.card)) {
                                playsMade = true;
                                cardsPlayedThisTurn++;

                                // Check for win condition again after play
                                if (player.stockpile.length === 0) {
                                    this.app.logEvent('SUCCESS', `${player.name} hat gewonnen!`);
                                    this.winner = player;
                                    return;
                                }
                            }
                        }
                    }
                }

                // --- 3. End Turn (Discard) ---
                if (this.winner === null) {
                    if (player.hand.length > 0) {
                        let discardCard;
                        let discardPileIndex;

                        if (player.isAI) {
                            // P1 (KI) Discard Strategy: Keep cards needed for stockpile. Discard high cards or cards that block a future 1-5 build.
                            // Simple KI: Discard the highest non-joker card on the pile with the lowest top card.

                            // Find a non-joker card to discard
                            let nonJokers = player.hand.filter(c => c !== JOKER_VALUE).sort((a, b) => b - a);
                            let cardToDiscard = nonJokers.length > 0 ? nonJokers[0] : JOKER_VALUE; // If only jokers, discard one joker

                            let cardIndex = player.hand.indexOf(cardToDiscard);
                            discardCard = player.hand.splice(cardIndex, 1)[0];

                            // Find the discard pile with the lowest top card to 'bury' the high card
                            discardPileIndex = 0;
                            let minTopCard = Infinity;
                            player.discardPiles.forEach((pile, index) => {
                                const topCard = pile.length > 0 ? pile[pile.length - 1] : 0;
                                if (topCard < minTopCard) {
                                    minTopCard = topCard;
                                    discardPileIndex = index;
                                }
                            });

                        } else {
                            // P2 (Random) Discard Strategy: Pick a random card and a random pile.
                            const randomIndex = Math.floor(Math.random() * player.hand.length);
                            discardCard = player.hand.splice(randomIndex, 1)[0];
                            discardPileIndex = Math.floor(Math.random() * DISCARD_PILE_COUNT);
                        }

                        player.discardPiles[discardPileIndex].push(discardCard);
                        this.app.logEvent('INFO', `${player.name} beendet Zug mit Ablage auf Stapel ${discardPileIndex + 1}.`);
                    } else {
                        this.app.logEvent('WARN', `${player.name} konnte keine Handkarten ablegen (Hand leer). Zug beendet.`);
                    }
                }
            }

            /**
             * Simulates a full game and returns the result object.
             */
            run() {
                this.createDeck();
                this.deal();
                this.winner = null;
                let currentTurn = 0;
                const startTime = Date.now();
                this.app.tempJokersPlayed = 0;

                // Start with P1, then alternate
                while (this.winner === null && currentTurn < 1000) { // Max 1000 turns to prevent infinite loops
                    const player = this.players[this.currentPlayerIndex];
                    currentTurn++;
                    this.app.logEvent('TURN', `Zug ${currentTurn}: ${player.name} startet.`);

                    this.playerTurn(player);

                    if (this.winner) {
                        break;
                    }

                    // Switch player
                    this.currentPlayerIndex = 1 - this.currentPlayerIndex;
                }

                const durationMs = Date.now() - startTime;

                return {
                    id: Math.floor(Math.random() * 999999) + 1,
                    winner: this.winner ? (this.winner.id === 0 ? 'Spieler 1 (KI)' : 'Spieler 2 (Random)') : 'TIE',
                    turns: currentTurn,
                    duration: durationMs,
                    starter: this.players[0].id === 0 ? 'P1' : 'P2', // Mock: P1 always starts
                    jokers: this.app.tempJokersPlayed,
                    strategy: this.winner && this.winner.isAI ? 'Optimiert' : 'Zufall'
                };
            }
        }

        // --- 2. Vue Application ---

        createApp({
            setup() {
                // --- Simulation Configuration Limits ---
                const minGames = 100;
                const maxGamesLimit = 10000;
                const stepGames = 100;
                const totalRows = 1000000; // Fixed for the data explorer table size

                // --- Simulation State ---
                const maxGamesConfig = ref(1000); // Default value from the slider
                const gameCounter = ref(0);
                const progress = ref(0);
                const isSimulating = ref(false);
                const isFinished = ref(false);
                const logs = ref([]);

                // --- Navigation State ---
                const currentView = ref('dashboard');

                // --- Statistical Results ---
                const realResults = reactive({
                    winsP1: 0,
                    winsP2: 0,
                    totalTurns: 0,
                    totalJokers: 0,
                });
                const tempJokersPlayed = ref(0); // Temporary counter for current game

                // --- Data Table State ---
                const rawData = ref([]); // Stores the generated rows
                const currentPage = ref(1);
                const pageSize = 15;

                // --- Charts Refs ---
                const winRateChartRef = ref(null);
                const durationChartRef = ref(null);
                let chartInstances = {};

                // --- Computed Statistics ---
                const winRateP1 = computed(() => maxGamesConfig.value > 0 && gameCounter.value > 0 ? realResults.winsP1 / gameCounter.value : 0);
                const averageTurns = computed(() => maxGamesConfig.value > 0 && gameCounter.value > 0 ? realResults.totalTurns / gameCounter.value : 0);
                const averageJokers = computed(() => maxGamesConfig.value > 0 && gameCounter.value > 0 ? realResults.totalJokers / gameCounter.value : 0);

                // --- Computed UI Helpers ---
                const formattedCounter = computed(() => gameCounter.value.toLocaleString('de-DE'));
                const buttonText = computed(() => {
                    if (isSimulating.value) return "Simuliere...";
                    if (isFinished.value) return "Simulation zurücksetzen";
                    return `${maxGamesConfig.value.toLocaleString('de-DE')} Runden Starten`;
                });
                const buttonClass = computed(() => {
                    if (isSimulating.value) return "bg-gray-800 text-gray-400 cursor-wait";
                    if (isFinished.value) return "bg-blue-600 text-white hover:bg-blue-700 shadow-lg";
                    return "bg-red-600 text-white hover:bg-red-700";
                });

                // --- Logging ---
                const logEvent = (type, text) => {
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString('de-DE', { hour12: false, fractionalSecondDigits: 2 });
                    let color = 'text-blue-400';
                    if (type === 'WARN') color = 'text-yellow-400';
                    if (type === 'SUCCESS') color = 'text-green-400';
                    if (type === 'TURN') color = 'text-gray-500';

                    // Only show a small subset of real-time logs to prevent UI overload
                    if (logs.value.length < 7 || type === 'RESET') {
                        logs.value.unshift({
                            id: Date.now() + Math.random(),
                            time: `[${timeStr}]`,
                            type: type,
                            color: color,
                            text: text
                        });
                    }
                    if (logs.value.length > 10) logs.value.pop();
                };

                // --- Data Generation Helper for Explorer (Mock based on real stats) ---
                const generateMockRow = (id, turns, jokers, winRate) => {
                    const isP1 = Math.random() < winRate;
                    return {
                        id: id,
                        winner: isP1 ? 'Spieler 1 (KI)' : 'Spieler 2 (Random)',
                        turns: Math.max(5, Math.floor(turns + (Math.random() - 0.5) * 10)), // Add slight variance
                        duration: Math.floor(Math.random() * 200) + 50,
                        starter: Math.random() > 0.5 ? 'P1' : 'P2',
                        jokers: Math.max(0, Math.round(jokers + (Math.random() - 0.5) * 2)),
                        strategy: isP1 ? 'Optimiert' : 'Zufall'
                    };
                };

                const paginatedData = computed(() => {
                    const start = (currentPage.value - 1) * pageSize;
                    const end = start + pageSize;
                    return rawData.value.slice(start, end);
                });

                // --- Pagination Handlers ---
                const nextPage = () => { if ((currentPage.value * pageSize) < totalRows) currentPage.value++; };
                const prevPage = () => { if (currentPage.value > 1) currentPage.value--; };

                // --- CSV Export Logic (Mocks a large export) ---
                const downloadCSV = () => {
                    let csvContent = "data:text/csv;charset=utf-8,";
                    csvContent += "GameID,Winner,Turns,Duration_ms,Starter,Jokers,Strategy\n";

                    // Generating 1000 rows for download demo based on real averages
                    for (let i = 1; i <= 1000; i++) {
                        const row = generateMockRow(i, averageTurns.value, averageJokers.value, winRateP1.value);
                        csvContent += `${row.id},${row.winner},${row.turns},${row.duration},${row.starter},${row.jokers},${row.strategy}\n`;
                    }

                    const encodedUri = encodeURI(csvContent);
                    const link = document.createElement("a");
                    link.setAttribute("href", encodedUri);
                    link.setAttribute("download", "skipbo_simulation_results_1000_sample.csv");
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                };

                // --- Simulation Core ---
                const runSimulation = () => {
                    if (isSimulating.value || isFinished.value) return;

                    isSimulating.value = true;
                    gameCounter.value = 0;

                    // Reset real results
                    realResults.winsP1 = 0;
                    realResults.winsP2 = 0;
                    realResults.totalTurns = 0;
                    realResults.totalJokers = 0;
                    rawData.value = []; // Clear previous data

                    const game = new SkipBoGame({ logEvent, tempJokersPlayed });
                    let batchSize = 100; // Run 100 games per batch to allow UI update
                    let totalGamesRun = 0;

                    logEvent('START', `Starte Echtsimulation von ${maxGamesConfig.value.toLocaleString('de-DE')} Runden...`);

                    const processBatch = () => {
                        const start = Date.now();

                        for (let i = 0; i < batchSize; i++) {
                            if (totalGamesRun >= maxGamesConfig.value) break;

                            const result = game.run();

                            // Collect real statistics
                            if (result.winner.includes('Spieler 1')) {
                                realResults.winsP1++;
                            } else if (result.winner.includes('Spieler 2')) {
                                realResults.winsP2++;
                            }
                            realResults.totalTurns += result.turns;
                            realResults.totalJokers += result.jokers;

                            // Store only a sample of the real game results for the table demo
                            if (rawData.value.length < pageSize) {
                                rawData.value.push(result);
                            }

                            totalGamesRun++;
                            gameCounter.value = totalGamesRun;
                        }

                        const end = Date.now();
                        const batchTime = end - start;
                        logEvent('INFO', `Batch ${Math.floor(totalGamesRun / batchSize)} beendet (${batchTime}ms).`);

                        progress.value = (totalGamesRun / maxGamesConfig.value) * 100;

                        if (totalGamesRun < maxGamesConfig.value) {
                            // Continue to the next batch
                            setTimeout(processBatch, 10); // Use setTimeout to prevent blocking the UI
                        } else {
                            // Simulation finished
                            isSimulating.value = false;
                            isFinished.value = true;

                            // Generate the 1M rows for the table explorer based on the real averages
                            // Note: totalRows is 1,000,000, we only store a visual sample for the table.
                            const numSamples = Math.min(totalRows, 500); // Limit sample size for memory
                            for (let i = 0; i < numSamples; i++) {
                                const mockRow = generateMockRow(totalRows - i, averageTurns.value, averageJokers.value, winRateP1.value);
                                rawData.value.push(mockRow);
                            }

                            logEvent('SUCCESS', `Simulation von ${maxGamesConfig.value.toLocaleString('de-DE')} Runden abgeschlossen!`);
                            nextTick(() => {
                                initCharts();
                            });
                        }
                    };

                    processBatch();
                };

                // --- Reset Functionality ---
                const resetSimulation = () => {
                    if (chartInstances.win) { chartInstances.win.destroy(); }
                    if (chartInstances.dur) { chartInstances.dur.destroy(); }
                    chartInstances = {};

                    gameCounter.value = 0;
                    progress.value = 0;
                    isSimulating.value = false;
                    isFinished.value = false;
                    rawData.value = [];
                    currentPage.value = 1;
                    realResults.winsP1 = 0;
                    realResults.winsP2 = 0;
                    realResults.totalTurns = 0;
                    realResults.totalJokers = 0;

                    currentView.value = 'dashboard';

                    logEvent('RESET', 'Simulation erfolgreich zurückgesetzt. Bereit für Neustart.');
                };

                // --- Charting ---
                const initCharts = () => {
                    if (chartInstances.win) { chartInstances.win.destroy(); }
                    if (chartInstances.dur) { chartInstances.dur.destroy(); }

                    if (!winRateChartRef.value || !durationChartRef.value) return;

                    Chart.defaults.font.family = "'Inter', sans-serif";

                    // Win Rate
                    chartInstances.win = new Chart(winRateChartRef.value, {
                        type: 'doughnut',
                        data: {
                            labels: ['Spieler 1 (Optimiert)', 'Spieler 2 (Zufall)'],
                            datasets: [{
                                data: [winRateP1.value * 100, (1 - winRateP1.value) * 100],
                                backgroundColor: ['#ef4444', '#cbd5e0'],
                                borderWidth: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            cutout: '75%',
                            plugins: { legend: { position: 'bottom', labels: { usePointStyle: true, padding: 20 } } }
                        }
                    });

                    // Duration (Mock distribution based on real average turns)
                    const avg = averageTurns.value;
                    chartInstances.dur = new Chart(durationChartRef.value, {
                        type: 'bar',
                        data: {
                            labels: [`< ${Math.floor(avg - 7)}`, `${Math.floor(avg - 7)}-${Math.floor(avg - 3)}`, `${Math.floor(avg - 3)}-${Math.floor(avg + 3)}`, `${Math.floor(avg + 3)}-${Math.floor(avg + 7)}`, `> ${Math.floor(avg + 7)}`],
                            datasets: [{
                                label: 'Anzahl Spiele',
                                data: [100000, 300000, 450000, 100000, 50000], // Mock distribution
                                backgroundColor: '#ef4444',
                                borderRadius: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: { y: { display: false }, x: { grid: { display: { color: '#e2e8f0' } } } },
                            plugins: { legend: { display: false } }
                        }
                    });
                };

                // --- Navigation Helper ---
                const navClass = (view) => {
                    return currentView.value === view
                        ? 'bg-red-50 text-red-700 font-bold'
                        : 'hover:bg-gray-50 hover:text-red-600';
                };

                // --- Scenarios Data (Static) ---
                const scenarios = reactive({
                    1: {
                        title: "Der Blocker",
                        desc: "Sollte man eigene Karten zurückhalten, um den Gegner zu blockieren?",
                        stacks: [
                            { label: "Gegner", value: "7", styleClass: "bg-red-50 text-red-600 border-red-200" },
                            { label: "Deine Hand", value: "7", styleClass: "bg-blue-50 text-blue-600 border-blue-500 ring-2 ring-blue-200" }
                        ],
                        analysis: "<strong>KI Entscheidung: JA.</strong> Es lohnt sich in 82% der Fälle, den eigenen Fortschritt zu opfern, wenn man den Gegner damit sicher blockieren kann. Das Blockieren des aktuellen Bedarfs des Gegners ist ein hoher Wert."
                    },
                    2: {
                        title: "Hand-Management",
                        desc: "Hand leer spielen vs. strategisches Abwerfen.",
                        stacks: [
                            { label: "Hand", value: "K", styleClass: "bg-gray-50 text-gray-800" },
                            { label: "Hand", value: "2", styleClass: "bg-gray-50 text-gray-800" }
                        ],
                        analysis: "<strong>KI Entscheidung: LEER SPIELEN.</strong> Die Wahrscheinlichkeit, einen Joker oder eine nützliche Karte zu ziehen, steigt drastisch, wenn man 5 neue Karten zieht. Immer versuchen, die Hand in einem Zug komplett zu spielen, um 5 neue Karten zu erhalten."
                    },
                    3: {
                        title: "Ablage-Priorität",
                        desc: "Karten von der Hand oder vom Ablagestapel nutzen?",
                        stacks: [
                            { label: "Ablage", value: "5", styleClass: "bg-orange-50 text-orange-600 border-orange-300" },
                            { label: "Hand", value: "5", styleClass: "bg-white text-gray-400 border-dashed" }
                        ],
                        analysis: "<strong>KI Entscheidung: ABLAGESTAPEL.</strong> Karten im Ablagestapel sind 'totes Kapital'. Befreie sie immer zuerst, um Zugriff auf die darunter liegenden Karten zu bekommen und die Vielfalt der Spielmöglichkeiten zu erhöhen."
                    }
                });
                const activeScenarioId = ref(1);
                const activeScenario = computed(() => scenarios[activeScenarioId.value]);

                watch(currentView, (newView) => {
                    if (newView === 'dashboard' && isFinished.value) {
                        nextTick(() => initCharts());
                    }
                });

                // Watch for changes in maxGamesConfig and reset simulation state if not finished
                watch(maxGamesConfig, () => {
                    if (!isSimulating.value) {
                        resetSimulation();
                    }
                });


                return {
                    minGames,
                    maxGamesLimit,
                    stepGames,
                    maxGamesConfig,
                    totalRows,
                    currentView,
                    gameCounter,
                    progress,
                    isSimulating,
                    isFinished,
                    logs,
                    buttonText,
                    buttonClass,
                    formattedCounter,
                    runSimulation,
                    resetSimulation,
                    winRateChartRef,
                    durationChartRef,
                    rawData,
                    paginatedData,
                    currentPage,
                    pageSize,
                    nextPage,
                    prevPage,
                    downloadCSV,
                    navClass,
                    scenarios,
                    activeScenarioId,
                    activeScenario,
                    winRateP1,
                    averageTurns,
                    averageJokers,
                    tempJokersPlayed,
                    logEvent
                };
            }
        }).mount('#app');
    </script>
</body>

</html>